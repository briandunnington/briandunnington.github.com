Title: Locks and async/await in .NET
Date: 2012.12.12
Summary: The new async/await keywords in .NET make async programming a snap, but there are some things to watch out for when synchronizing multiple threads.

<!-- Main hero unit for a primary marketing message or call to action -->
<div class="hero-unit">
<h1>Locks and async/await in .NET</h1>
<p>The new async/await keywords in .NET make async programming a snap, but there are some things to watch out for when synchronizing multiple threads.</p>
<!--<p><a class="btn btn-primary btn-large">Learn more &raquo;</a></p>-->
</div>

So you have had your head down coding up your awesome new [Windows Store][WindowsStore] and [Windows Phone][WindowsPhone] apps, and the new <code>async/await</code> keywords are making life a lot easier. No more frankenstein code of callbacks and Invokes() littering up your beautiful codebase.

Now you need to load some data for use in your app. Could come from a webservice, or maybe a long-running local database query. Or maybe you have some initialization code that you want to ensure only runs once, even when multiple threads are involved. Easy enough - in the olden-days, you would wrap a <code>lock</code> statement around the critical sections and be on your merry way.

If your critical section contains <code>await</code>-ed code though, suddenly the compiler is complaining. The [MSDN][MsdnAwait] documentation says:

> Within the method, lambda expression, or anonymous method, an await expression cannot occur in the body of a synchronous function, in a query expression, in the catch or finally block of an exception handling statement, **in the block of a lock statement**, or in an unsafe context.

If you are wondering why, Eric Lippert (former member of the C# language design committee ) [says][Lippert] that "it is an incredibly bad idea and so we don't allow it, so as to protect you from making this mistake." Why is it a bad idea? He goes on to say:

> Awaiting inside a lock is a recipe for producing deadlocks [because] arbitrary code runs between the time the await returns control to the caller and the method resumes. That arbitrary code could be taking out locks that produce lock ordering inversions, and therefore deadlocks.

Alright, so putting a <code>lock</code> around async code is a bad idea and not allowed. So what are the alternatives?

.NET has a bunch of synchonrization primitives built in, and with the 4.5 version, they have been updated and extended. Of particular interest is [SemaphoreSlim][] 



[WindowsStore]: http://www.windowsstore.com/
[WindowsPhone]: https://dev.windowsphone.com/
[MsdnAwait]: http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx
[Lippert]: http://stackoverflow.com/a/7612714/373799
[SemaphoreSlim]: 